[{"/Users/dea/Code/Projects/animetimeline/src/index.js":"1","/Users/dea/Code/Projects/animetimeline/src/App.js":"2","/Users/dea/Code/Projects/animetimeline/src/Components/WholeViz.js":"3","/Users/dea/Code/Projects/animetimeline/src/Components/HeroSection.js":"4","/Users/dea/Code/Projects/animetimeline/src/Components/AnimeTimeline.js":"5","/Users/dea/Code/Projects/animetimeline/src/Components/Footer.js":"6","/Users/dea/Code/Projects/animetimeline/src/Components/AnimeGraph.js":"7","/Users/dea/Code/Projects/animetimeline/src/Components/genres.js":"8"},{"size":150,"mtime":1638113059652,"results":"9","hashOfConfig":"10"},{"size":169,"mtime":1638113059644,"results":"11","hashOfConfig":"10"},{"size":3883,"mtime":1638113059650,"results":"12","hashOfConfig":"10"},{"size":1433,"mtime":1659722340071,"results":"13","hashOfConfig":"10"},{"size":5843,"mtime":1638113059647,"results":"14","hashOfConfig":"10"},{"size":1508,"mtime":1638113059648,"results":"15","hashOfConfig":"10"},{"size":18255,"mtime":1638113059646,"results":"16","hashOfConfig":"10"},{"size":1148,"mtime":1638113059650,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"14opcmm",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"25","usedDeprecatedRules":"20"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"28","messages":"29","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"20"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"20"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"20"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"20"},"/Users/dea/Code/Projects/animetimeline/src/index.js",[],["40","41"],"/Users/dea/Code/Projects/animetimeline/src/App.js",[],"/Users/dea/Code/Projects/animetimeline/src/Components/WholeViz.js",["42"],"import React, { useState, useEffect } from \"react\";\nimport * as d3 from \"d3\";\nimport _ from \"lodash\";\n//import dataLoad from \"../data/mal_scrape_Jan8_limited.json\";\nimport HeroSection from \"./HeroSection\";\nimport AnimeTimeline from \"./AnimeTimeline\";\nimport AnimeGraph from \"./AnimeGraph\";\nimport Footer from \"./Footer\";\n\nconst dataURL = \"https://gist.githubusercontent.com/deaxmachina/f795176fbfd340cce82373d682cedd43/raw/124f2d14c04e30a7f74b6c04aab9b21e89f80d4c/mal_scrape_Jan8_limited.json\";\n\n\nconst WholeViz = () => {\n\n  /// states ///\n  const [data, setData] = useState(null);\n  const [allData, setAllData] = useState(null)\n  const [selectedYear, setSelectedYear] = useState(2020)\n  const [studios, setStudios] = useState(null);\n\n  // to have animated div only on bigger screen size \n  const [isDesktop, setIsDesktop] = useState(true)\n  const [desktopSize, setDesktopSize] = useState(null);\n  const updatePredicate = function () {\n    setIsDesktop(window.innerWidth > 1500)\n    setDesktopSize(window.innerWidth)\n  }\n  useEffect(() => {\n    updatePredicate();\n    window.addEventListener(\"resize\", updatePredicate);\n  }, [])\n\n  /// Data load ///\n\n  useEffect(() => {\n\n    d3.json(dataURL).then(dataLoad => {\n      // transform data into just {year: 2020, number_anime: 800}\n      // group the anime by year\n      const mygroup = _.groupBy(dataLoad, function(anime){return anime.air_year})\n      // transform the data so we end up with objects with year and number of unique anime in that year by mal_id \n      const mygroupData = []\n        for (const [year, data] of Object.entries(mygroup)) {\n            mygroupData.push({\n                year: year,\n                number_animes: (_.uniqBy(data, 'mal_id')).length\n            })\n        }\n        // filter to the years that you want\n        const filteredCountsList = _.filter(mygroupData, function(o) { \n          return o.year >= 1970 && o.year <= 2020\n        });\n      setData(filteredCountsList)\n\n      // Get list of studios \n      // 1. add category for list of studios for each anime\n      dataLoad.forEach(d => d.studiosList = _.map(d.producers, \"name\"))\n      // 2. get list of studios; flatten it and count by number of appearance \n      const studios = _.map(dataLoad, d => d.studiosList)\n      const studiosCounts = _.countBy(_.flatten(studios))\n      // 3. sort the studious by number of appearance \n      let sortedStudios = _.chain(studiosCounts).\n          map(function(count, studio) {\n              return {\n                  studio: studio,\n                  count: count\n              }\n          })\n          .sortBy('count')\n          .value()\n      sortedStudios = _.reverse(sortedStudios)\n      setStudios(sortedStudios)\n      setAllData(dataLoad)\n    })\n    \n\n\n  }, []);\n\n\n  return (\n    <div id=\"whole-graph-petalscircles\">\n      <HeroSection />\n      <div className=\"whole-graph-petalscircles-container\">\n        <AnimeTimeline\n          data={data}\n          allData={allData}\n          selectedYear={selectedYear}\n          setSelectedYear={setSelectedYear}\n        />\n\n        {\n          isDesktop\n          ?\n            <AnimeGraph\n              desktopSize={desktopSize}\n              allData={allData}\n              selectedYear={selectedYear}\n              setAllData={setAllData}\n              studios={studios}\n              width={1300}\n              height={750}\n              minPopularity={7}\n              maxPopularity={37}\n            />\n          :\n            <AnimeGraph\n              desktopSize={desktopSize}\n              allData={allData}\n              selectedYear={selectedYear}\n              setAllData={setAllData}\n              studios={studios}\n              width={1300}\n              height={650}\n              minPopularity={5}\n              maxPopularity={35}\n            />\n        }\n\n      </div>\n      <Footer />\n    </div>\n  )\n};\n\nexport default WholeViz;","/Users/dea/Code/Projects/animetimeline/src/Components/HeroSection.js",["43","44"],"/Users/dea/Code/Projects/animetimeline/src/Components/AnimeTimeline.js",["45","46","47","48","49"],"import React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport _ from \"lodash\";\nimport * as chroma from \"chroma-js\";\n\n\nconst AnimeTimeline = ({ \n  data, allData, selectedYear, setSelectedYear \n  }) => {\n\n  /// refs ///\n  const svgRef = useRef();\n  const xAxisRef = useRef();\n  const gRef = useRef();\n  const rectRef = useRef();\n\n  /// constatns ///\n  // dimensions \n  const width = 1300;\n  const heightRect = 100;\n  const height = 100;\n  const margin = {top: 35, bottom: 45, right: 10, left: 10}\n  // radius of the timeline circles \n  const minRadiusTimeline = 11;\n  const maxRadiusTimeline = 19;\n  // colours \n  const shapeBackgroundColour = \"#010B14\" //  \"#14213d\" \n  const lowNumberColour = \"#003f66\" // \"#4361ee\" \"#268ECF\"\n  const highNumberColour =  \"#268ECF\" // \"#f72585\" \"#4361ee\"\n  const axisTextColour = \"white\"\n\n\n    /// D3 Code ///\n  useEffect(() => {\n    if (data && allData) {\n\n      /// Scales ///\n      // X Scale \n      const xScale = d3.scaleBand()\n        .domain(data.map(d => d['year'])) // all years\n        .range([margin.left, width - margin.right])\n        .padding(0.1)\n\n      // Colour scale - number of anime per year\n      // find the min and the max number of anime in any given year \n      // for now just using 0 to 1200 hardcoded \n      const colorScale = chroma.scale([lowNumberColour, highNumberColour]\n        .map(color => chroma(color).saturate(0)))\n        .domain([0, 1110])\n      // Scale the circles of the timeline by number of anime of that year\n      const numberAnimeScale = d3.scaleSqrt()\n        .domain(d3.extent(data, d => d.number_animes))\n        .range([minRadiusTimeline, maxRadiusTimeline])\n\n      const g = d3.select(gRef.current)\n\n      /// Axes ///\n      // X Axis \n      const xAxis = g => g  \n        .attr(\"transform\", `translate(${0}, ${heightRect - margin.bottom})`)\n        .call(d3.axisBottom(xScale).tickFormat(i => i).tickSizeOuter(0))\n        .call(g => g.select(\".domain\").remove())\n        .call(g => g.selectAll(\"text\")\n          .style(\"fill\", axisTextColour)\n          .attr(\"font-size\", \"0.9em\")\n          .style(\"text-anchor\", \"end\")\n          .attr(\"dx\", \"-.8em\")\n          .attr(\"dy\", \".15em\")\n          .attr(\"transform\", \"rotate(-60)\")\n        )\n        .call(g => g.selectAll(\".tick\")\n          .style(\"color\", axisTextColour)\n        )\n      \n      // for the instructions text above the graph \n      const instructionsText = g\n        .selectAll(\".instructions-text\")\n        .data([\"click on a circle to filter anime by year\"])\n        .join(\"text\")\n        .classed(\"instructions-text\", true)\n        .attr(\"transform\", `translate(${margin.left + 5}, ${margin.top/2 - 12})`)\n        .text(d => d)\n        .attr(\"font-size\", \"14px\")\n        .attr(\"fill\", \"white\")\n        .attr(\"dy\", \"0.35em\")\n\n      /// Graph ///\n\n      // draw a rectangle behind the circles \n      const rectBackground = d3.select(rectRef.current)\n        .append(\"rect\")\n        .attr(\"rx\", 30)\n        .attr(\"ry\", 30)\n        .attr(\"width\", width)\n        .attr(\"height\", heightRect)\n        .attr('fill', shapeBackgroundColour) \n\n      // draw one circle for each year, coloured by number of anime\n      const yearCircles = g\n        .selectAll(\".year-circles\")\n        .data(data)\n        .join(\"circle\")\n        .classed(\"year-circles\", true)\n          .attr(\"r\", d => numberAnimeScale(d['number_animes']))\n          .attr(\"cx\", d => xScale(d['year']) + xScale.bandwidth()/2)\n          .attr(\"cy\", heightRect/3)\n          .attr(\"fill\", d => colorScale(d['number_animes']))\n          .attr(\"fill-opacity\", 1)\n          .attr(\"stroke\", d => colorScale(d['number_animes']))\n          // if you want the stroke to scale with size of circle\n          //.attr(\"stroke-width\", d => numberAnimeScale(d['number_animes']) * 0.5)\n          // if you want the stroke to be constant\n          .attr(\"stroke-width\", 8)\n          .attr(\"stroke-opacity\", 0.5)\n     \n      // add text with number of animes on top of each circle \n      const yearCirclesText = g\n          .selectAll(\".circles-text\")\n          .data(data)\n          .join(\"text\")\n          .classed(\"circles-text\", true)\n            .attr(\"x\", d => xScale(d['year']) + xScale.bandwidth()/2)\n            .attr(\"y\", heightRect/3)\n            .attr(\"dy\", \".35em\")\n            .text(d => d['number_animes'])\n            .attr(\"fill\", axisTextColour)\n            .attr(\"font-size\", \"8px\")\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"opacity\", 0.8)\n            .attr('cursor', 'default')\n            .attr('pointer-events', 'none')\n            .attr(\"id\", d => d['year'])\n      \n      // set up events on the circles \n      yearCircles\n        .on(\"mouseenter\", onMouseEnter)\n        .on(\"mouseleave\", onMouseLeave)\n        .on(\"click\", onClick)\n      \n      function onClick(e, datum) {\n        setSelectedYear(datum['year'])\n        // expand the radius \n        d3.select(this).attr(\"r\", d => 1.5 * numberAnimeScale(d['number_animes']))\n      }\n      function onMouseEnter(e, datum) {\n        // expand the radius \n        d3.select(this).attr(\"r\", d => 1.5 * numberAnimeScale(d['number_animes']))\n      }\n\n      function onMouseLeave(e, datum) {\n        // shrink the radius back to normal\n        d3.select(this).attr(\"r\", d => numberAnimeScale(d['number_animes']))\n      }\n\n      // call the axes \n      d3.select(xAxisRef.current).call(xAxis)\n\n    } else {\n      console.log(\"Missing data\")\n    }\n  }, [data, allData]);\n\n\n  return (\n    <div>\n      <p className=\"timeline-title\">Timeline - number of anime per year</p>\n      <br />\n      <div id=\"anime-timeline-wrapper\">\n        <svg ref={svgRef} width={width} height={height}>\n          <g ref={rectRef}></g>\n          <g ref={gRef}></g>\n          <g ref={xAxisRef}></g>\n        </svg>\n      </div>\n    </div>\n  )\n}\n\nexport default AnimeTimeline;","/Users/dea/Code/Projects/animetimeline/src/Components/Footer.js",["50","51"],"import React from \"react\";\n\nconst Footer = () => {\n  return (\n    <div className=\"whole-graph-petalscircles-footer\">  \n      <p className=\"whole-graph-petalscircles-methodology\">Methodology</p>\n      <ul className=\"whole-graph-petalscircles-methodology-list\">\n        <li>\n          For each anime, the anime is displayed once, even if it ran over multiple seasons. For long-running anime that means they end up being put in the winter season as it is the first of the year.\n        </li>\n        <li>\n          The colouring of the genres is based on a completely subjective ordering of \"seriousness\", aiming to give a visual representation of what kind of anime are most popular. \n        </li>\n        <li>\n          \"Popular but low score anime\" are defined as anime with number of members who have seen it in the 75th percentile, but with mean score below 6.5/10.\n        </li>\n      </ul>\n      <p className=\"whole-graph-petalscircles-p\">\n        Data from \n        <a href=\"https://myanimelist.net/\" target=\"_blank\"> MyAnimeList</a>. \n        I do not own any of the data.\n      </p>   \n      <p className=\"whole-graph-petalscircles-p\">\n        Project as part of 100DaysOfCode with D3.js challenge. Project inspiration: Shirley Wu Front End Masters \n        <a href=\"https://frontendmasters.com/courses/d3/\" target=\"_blank\"> course</a>.\n      </p>\n      <p className=\"whole-graph-petalscircles-p\">made by  \n        <span> Dea Bankova </span>©2021\n      </p>\n    </div>\n  )\n};\n\nexport default Footer;","/Users/dea/Code/Projects/animetimeline/src/Components/AnimeGraph.js",["52","53","54","55","56","57","58","59","60","61","62","63"],"import React, { useState, useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport _ from \"lodash\";\nimport { orderedGenres, colourScaleOrderedGenres, hentaiGenres } from \"./genres.js\"\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faArrowRight, faRadiation } from '@fortawesome/free-solid-svg-icons'\n\n\n// options for the petal paths //\nconst petalPaths = [\n    'M0 0 C50 50 50 100 0 100 C-50 100 -50 50 0 0',\n    'M0 0 C1 1 1 2 0 2 C-1 2 -1 1 0 0',\n    'M-35 0 C-25 25 25 25 35 0 C50 25 25 75 0 100 C-25 75 -50 25 -35 0',\n    'M0,0 C50,40 50,70 20,100 L0,85 L-20,100 C-50,70 -50,40 0,0',\n    'M0 0 C50 25 50 75 0 100 C-50 75 -50 25 0 0',\n    \"M 0,0 a 25,25 0 1,1 50,0a 25,25 0 1,1 -50,0\",\n    \"M 0 -1 c 99 -45 74 -95 149 -97 c 87 0 85 98 227 97 c -142 1 -144 87 -228 88 c -77 1 -48 -52 -148 -88\",\n    \"M 0 0 c 0 29 49 19 50 -16 c -17 5 -43 -55 -50 16\",\n    \"M 0 0 C 59 26 48 79 10 63 L 0 68 L -9 63 C -46 78 -59 27 0 0\"\n]\n\n\nconst AnimeGraph = ({ \n  allData, selectedYear, setAllData, width, height, minPopularity, maxPopularity, desktopSize\n}) => {\n\n  const [selectedAnime, setSelectedAnime] = useState(null)\n\n  /// refs ///\n  const svgRef = useRef();\n  const xAxisRef = useRef();\n  const yAxisRef = useRef();\n  const gRef = useRef();\n  const nodesRef = useRef();\n  const legendRef = useRef();\n  const legendRectsAxisRef = useRef();\n  const tooltipRef = useRef();\n  const resetButtonRef = useRef();\n  const underratedButtonRef = useRef();\n\n  /// constatns ///\n  // dimensions \n  const legendHeight = 60;\n  const margin = {top: 20, bottom: legendHeight + 20, right: 30, left: 70}\n  \n  // for the lower and upper limit of the popularity scale\n  //const minPopularity = 7\n  //const maxPopularity = 47\n  // scale of the petals \n  const petalScale = 0.008 * 2;\n  // colours \n  const shapeBackgroundColour = \"#010B14\";\n  const lightColour =  \"#fff1e6\";\n  const circleOutlineHoverColour = \"black\"\n  const HentaiColour = \"#E2C6B6\";\n  const allGenresColour = \"#003f66\" //\"#2a9d8f\";\n\n  // for the filtering of anime \n  const underratedPercentile = 0.6;\n  const underratedScore = 7.5; // represents high score \n\n  const overratedPercentile = 0.75;\n  const overratedScore = 6.5; // represents low score \n\n\n  /// D3 Code ///\n  useEffect(() => {\n    if (allData && selectedYear) {\n\n      //////////////////////////////////////\n      ////////////// DATA //////////////////\n      //////////////////////////////////////\n      // get only one year \n      let dataOneYear = _.filter(allData, {'air_year': parseInt(selectedYear)});\n      // only the unique anime for the year \n      const dataOneYearUniq = _.uniqBy(dataOneYear, 'mal_id')\n      // get list of sorted members for computing the low and high quantiles\n      const sortedMembers = _.uniq(_.sortBy(allData, d => d.members).map(d => d.members))\n      const lowQuantileMembers = d3.quantile(sortedMembers, underratedPercentile)\n      const highQuantileMembers = d3.quantile(sortedMembers, overratedPercentile)\n\n      //////////////////////////////////////\n      /////////////// GRAPH ////////////////\n      //////////////////////////////////////\n      /// Scales ///\n      // X Scale \n      // use a band scale to position all the anime in the year horizontally \n      // this is needed with the force as it requires an x-position that \n      // the circles should move towards \n      const xScale = d3.scaleBand()\n        .domain(['winter', 'summer', 'spring', 'fall']) // the seasons in a year \n        .range([30, width - margin.right])\n        .padding(0.1)\n      // Y Scale - corresponds to the score of anime \n      const yScale = d3.scaleLinear()\n        .domain([d3.min(allData, d => d.score) + 1.5, d3.max(allData, d => d.score) + 1])\n        .range([height - margin.bottom, margin.top])\n      // Popularity scale - number of members who have seen the anime \n      const popularityScale = d3.scaleSqrt()\n        .domain(d3.extent(allData, d => d.members))\n        .range([minPopularity, maxPopularity])\n\n      // add radius for convenience\n      dataOneYearUniq.forEach(d => d.r = popularityScale(d.members))\n      // get list of the genres of anime\n      dataOneYearUniq.forEach(d => d.genresList = _.map(d.genres, \"name\"))\n      \n\n      /// Axes ///\n      // X Axis \n      const xAxis = g => g  \n        .attr(\"transform\", `translate(${100}, ${margin.top/2})`)\n        .call(d3.axisBottom(xScale).tickFormat(i => i).tickSizeOuter(0))\n        .call(g => g.select(\".domain\").remove())\n        .call(g => g.selectAll(\"text\")\n          .style(\"text-anchor\", \"start\")\n          .attr(\"font-size\", \"1.9em\")\n          .attr(\"class\", \"season\")\n          .style(\"color\", lightColour)\n        )\n        .call(g => g.selectAll(\".tick\")\n          .style(\"color\", shapeBackgroundColour)\n        )\n\n      // Y Axis \n      const yAxis = g => g\n        .attr(\"transform\", `translate(${margin.left}, ${0})`)\n        .call(d3.axisLeft(yScale).ticks(3))\n        .call(g => g.select(\".domain\").remove())\n\n      /// Graph ///\n      const svg = d3.select(gRef.current)\n        .attr(\"transform\", `translate(${margin.left}, ${0})`)\n\n      // text on the side of the y axis \n      const yAxisSideText = svg.selectAll(\".y-axis-side-text\").data([\"average user score of anime\"]).join(\"text\")\n        .classed(\"y-axis-side-text\", true)\n          .attr(\"x\", -height/2 + margin.top)\n          .attr(\"y\", -margin.left / 2)\n          .attr(\"text-anchor\", \"start\")\n          .attr(\"dy\", \"0.35em\")\n          .attr(\"font-size\", \"14px\")\n          .attr(\"fill-opacity\", 1)\n          .attr(\"opacity\", 1)\n          .attr(\"fill\", 'white')\n          .attr(\"transform\", `rotate(${-90})`)\n          .text(d => d)\n\n\n      // Force Simulation - to make the shapes not collide with each other\n      // note that we first remove the anime without a score as we don't want to visualise these \n      const dataOneYearUniqWithScores = _.filter(dataOneYearUniq, function(anime){ return anime['score'] !== null})\n      const simulation = d3.forceSimulation(dataOneYearUniqWithScores, d => d.mal_id)\n        // x is computed with the band scale \n        .force('x', d3.forceX().strength(0.3).x(d => xScale(d['air_season']) + xScale.bandwidth()/2))\n        // y is computed with the score \n        .force('y', d3.forceY().strength(0.9).y(d => yScale(d['score'])))\n        .force('collide', d3.forceCollide().radius(d => d.r + 2.5).strength(1)) // the + 2.5 is to leave some space between the circles \n  \n      // shapes - one for each anime; apply force simulation to these; also apply any click events at this level \n      const shapes = svg\n        .selectAll(\".shape-container\")\n        .data(simulation.nodes(), d => d['mal_id'])\n        .join(\"g\")\n        .classed(\"shape-container\", true)\n          .attr(\"opacity\", 0)\n          .attr('transform', d => `translate(${ d.x },${ d.y })`) \n        \n      // background for the shapes, e.g. \n      // a circle that contains the flowers for each anime\n      const shapesBackground = shapes.selectAll(\"circle\")\n        .data(d => [d])\n        .join(\"circle\")\n        .attr(\"r\", d => d.r)\n        .attr(\"fill\", shapeBackgroundColour)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"stroke\", lightColour)\n        .attr(\"stroke-width\", d => d.r * 0.15)\n        .attr('stroke-opacity', 1)\n\n      // the flower of shape for each anime based on the number of genres \n      const flowers = shapes.selectAll(\"path\")\n        .data(d => d.genres)\n        .join(\"path\")\n          .attr(\"d\", petalPaths[5]) // 7 or 5 \n          // the last arg nodes gives us access to the whole data\n          .attr(\"transform\", function(d, i, nodes){\n            const allData = d3.selectAll(nodes).data() // all data for this selection\n            const parentData = this.parentNode.__data__ // parent data\n            return `rotate(${i * (360 / (allData.length || 1))})scale(${petalScale * parentData.r || 0.2})`\n          })         \n          .attr(\"fill\", function(d, i, nodes){\n            const parentData = this.parentNode.__data__ // parent data\n            const genres = parentData.genres\n            // look up the indices of the genres in the ordered array of orderedGenres \n            // and use these to sort the anime in the order in which they appear in the orderedGenres \n            // so that we can have the petals form nice gradients when they have adjacent genres \n            const genresSorted = genres.sort((a, b) => {\n              return _.indexOf(orderedGenres, a.name) - _.indexOf(orderedGenres, b.name) \n            })\n            const genre =  genresSorted[i].name // get genre from parent data \n            // fill from the cat-based colour scheme \n            const fill = _.includes(orderedGenres, genre) \n              ? colourScaleOrderedGenres[_.indexOf(orderedGenres, genre)] \n              : HentaiColour\n            return fill\n          })\n          .attr(\"fill-opacity\", 0.83)\n          // same as fill\n          .attr(\"stroke\", function(d, i, nodes){\n            const parentData = this.parentNode.__data__ // parent data\n            const genres = parentData.genres\n            const genresSorted = genres.sort((a, b) => {\n              return _.indexOf(orderedGenres, a.name) - _.indexOf(orderedGenres, b.name) \n            })\n            const genre =  genresSorted[i].name // get genre from parent data \n            const fill = _.includes(orderedGenres, genre) \n              ? colourScaleOrderedGenres[_.indexOf(orderedGenres, genre)] \n              : HentaiColour\n            return fill\n          })\n          .attr(\"stroke-width\", 7)\n          .attr(\"stroke-opacity\", 0.3)\n\n      // ticks control the force simulation; translate the flowers to the right place\n      function tick() {\n        shapes\n        .attr('transform', d => `translate(${ d.x },${ d.y })`) \n      }\n      simulation.on(\"tick\", tick)\n\n      // shapes fade in; otherwise they enter from weird places\n      setTimeout(() => {\n        simulation.restart();\n        shapes\n          .transition()\n          .attr(\"opacity\", 1)\n      }, 100);\n      // show the initial arrangement\n      //tick();\n\n      // call the axes \n      d3.select(yAxisRef.current).call(yAxis)\n      d3.select(xAxisRef.current).call(xAxis)\n\n\n      //////////////////////////////////////////\n      //////////////// LEGEND //////////////////\n      //////////////////////////////////////////\n      const legend = d3.select(legendRef.current)\n        .attr(\"transform\", `translate(${0}, ${height + margin.top})`)\n\n      const xScaleLegend = d3.scaleBand()\n        .domain([...orderedGenres, ...hentaiGenres]) \n        .range([margin.left, width - margin.right + 45])\n        .padding(0.1)\n      \n      const legendRects = legend\n        .selectAll(\".legend-rect\")\n        .data([...orderedGenres, ...hentaiGenres])\n        .join(\"rect\")\n        .classed(\"legend-rect\", true)\n        .attr('height', 17)\n        .attr(\"width\", 24)\n        .attr(\"x\", (d, i) => xScaleLegend(d) + xScaleLegend.bandwidth()/2)\n        // fill based on genres, with the hentai genres separately and add a square with a different colour of \"all\" genres\n        .attr('fill', (d, i) => _.includes(orderedGenres, d) \n          ? colourScaleOrderedGenres[i] \n          : HentaiColour \n          )\n        .attr(\"opacity\", 0.8)\n\n      const legendRectsAxis = g => g  \n        .attr(\"transform\", `translate(${0}, ${height + margin.top + 20})`)\n        .attr(\"class\", \"legend-rects-xaxis\")\n        .call(d3.axisBottom(xScaleLegend).tickFormat(i => i).tickSizeOuter(0))\n        .call(g => g.select(\".domain\").remove())\n        .call(g => g.selectAll(\"text\")\n          .style(\"fill\", lightColour)\n          .attr(\"font-size\", \"1em\")\n          .style(\"text-anchor\", \"end\")\n          .attr(\"dy\", \".35em\")\n          .attr(\"dx\", \".35em\")\n          .attr(\"transform\", \"rotate(-30)\")\n        )\n        .call(g => g.selectAll(\".tick\")\n          .style(\"color\", shapeBackgroundColour)\n        )\n      d3.select(legendRectsAxisRef.current).call(legendRectsAxis)\n\n      // the genre text which is updated when a genre rect is clicked\n      const legendSelectedGenreText = legend\n        .selectAll(\".legend-selected-genre-text\")\n        .data([0])\n        .join(\"text\")\n        .classed(\"legend-selected-genre-text\", true)\n          .attr(\"transform\", `translate(${margin.left + 15}, ${-15})`)\n          .text(\"all genres\")\n          .attr(\"fill\", lightColour)\n          .style(\"text-anchor\", \"start\")\n          .attr(\"font-size\", \"2em\")\n\n      // bit of the text that stays constant and just says \"selected genre\"\n      const legendSelectedGenreTextFront = legend\n        .selectAll(\".legend-selected-genre-text-front\")\n        .data([0])\n        .join(\"text\")\n        .classed(\"legend-selected-genre-text-front\", true)\n          .attr(\"transform\", `translate(${margin.left + 15}, ${-50})`)\n          .text(\"click on a square to filter by genre\")\n          .attr(\"fill\", lightColour)\n          .style(\"text-anchor\", \"start\")\n          .attr(\"font-size\", \"14px\")\n\n      // text with instructions to select genre \n      /*\n      const legendSelectedGenreTextInstructions = legend\n        .selectAll(\".legend-selected-genre-text-instructions\")\n        .data([0])\n        .join(\"text\")\n        .classed(\"legend-selected-genre-text-instructions\", true)\n          .attr(\"transform\", `translate(${width - margin.right + 50}, ${-15})`)\n          .text(\"click on a square to filter by genre\")\n          .attr(\"fill\", lightColour)\n          .style(\"text-anchor\", \"end\")\n          .attr(\"font-size\", \"0.85em\")\n          .attr(\"dy\", \"0.35em\")\n      */\n\n      /// Legend interactions ///\n      legendRects.on(\"click\", function(event, datum) {\n        const genre = datum \n        // the anime which contain that genre stay with opacity 1 and the other ones have reduced opacity. if there selected genre is \"all\", display everything \n        shapes.attr(\"opacity\", d => d.genresList.includes(genre) ? 1 : 0.1 \n        )\n        // change text to the genre in the text bit above the legend\n        legendSelectedGenreText.text(genre)\n      })\n      legendRects.on(\"mouseenter\", function(event, datum) {\n        // stroke the selected genre rect \n        legendRects\n          .attr(\"stroke\", d => d == datum ? lightColour : null)\n          .attr(\"stroke-width\", 2)\n      })\n      legendRects.on(\"mouseleave\", function(event, datum) {\n        legendRects\n          .attr(\"stroke\", null)\n      })\n\n      ////////////////////////////////////////\n      /////////// FILTER BUTTONS /////////////\n      ///////////////////////////////////////\n\n      // button for popular but low score\n\n      const underratedButton = d3.select(underratedButtonRef.current)\n        .on(\"click\", function(e, datum) {\n          shapes.attr(\"opacity\", 1)\n          legendSelectedGenreText.text(\"all genres\")\n        })\n        .on(\"click\", function() {\n          const overratedAnime = _.filter(allData, function(anime){ \n            return (anime.members >= highQuantileMembers && anime.score <= overratedScore)\n          })\n          shapes.attr(\"opacity\", d => overratedAnime.includes(d) ? 1 : 0.1)\n        })\n        .on(\"mouseenter\", function() {\n          underratedButton\n            .attr(\"stroke-width\", 3)\n        })\n        .on(\"mouseleave\", function() {\n          underratedButton\n            .attr(\"stroke-width\", 1)\n        })\n\n\n      // button for reset \n      const resetButton = d3.select(resetButtonRef.current)\n        .on(\"click\", function(){\n          shapes.attr(\"opacity\", 1)\n        })\n\n\n      //////////////////////////////////////\n      ////////////// TOOLTIP ///////////////\n      //////////////////////////////////////\n      // Include all the events here when an anime circle (shapes) is hovered or clicked \n      // i.e. the tooltip, stroke and the anime info that gets fetched \n      const tooltip = d3.select(tooltipRef.current)\n      // events to move the tooltip \n      shapes.on(\"click\", (event, element) => {\n        console.log(element)\n      })\n      shapes.on(\"mouseenter\", function(e, datum) {\n        shapesBackground\n          .attr(\"stroke\", d => d == datum ? circleOutlineHoverColour : lightColour)\n          .attr(\"fill\", d => d == datum ? lightColour : circleOutlineHoverColour)\n        tooltip \n          .style('transform', d => `translate(\n              ${desktopSize > 800 ? datum.x : 100}px,\n              ${datum.y + 80}px`\n            ) \n          .style(\"opacity\", 1)\n        // set the selected anime to the one corresponing to the hovered element \n        setSelectedAnime(datum)\n      })\n      shapes.on(\"mouseleave\", function(e, datum) {\n        shapesBackground\n          .attr(\"stroke\", lightColour)\n          .attr(\"fill\", shapeBackgroundColour)\n        tooltip.style(\"opacity\", 0)\n      })\n\n    } \n  }, [allData, selectedYear, width, height, desktopSize]);\n\n\n  return (\n      <div>\n        <h1 className=\"whole-graph-petalscircles-selected-year\">{selectedYear}</h1>\n        {\n            desktopSize > 1100\n              ? <div></div>\n              : <div>\n                  <span>scroll </span>\n                  <FontAwesomeIcon icon={faArrowRight} />\n                </div>\n          }\n        <div id=\"anime-graph-wrapper\">\n          <svg \n            ref={svgRef} \n            width={width + margin.left + margin.right} \n            height={height + margin.top + margin.bottom}\n          >\n            <g ref={gRef}>\n              <g ref={nodesRef}></g>\n            </g>\n            <g ref={xAxisRef}></g>\n            <g ref={yAxisRef}></g>\n            <g ref={legendRef}></g>\n            <g ref={legendRectsAxisRef}></g>\n          </svg>\n\n\n\n        </div>\n\n        <button ref={resetButtonRef} className=\"reset-button\">reset</button>\n        <button ref={underratedButtonRef} className=\"underrated-button\">popular but low score</button>\n\n        <div id=\"tooltip\" className=\"tooltip\" ref={tooltipRef}>\n          {selectedAnime \n          ? <div>\n              <span className=\"tooltip-title\">{selectedAnime.title}</span>\n              <span className=\"tooltip-info\">MAL members: {d3.format(\",.2r\")(selectedAnime.members)}</span>\n              <span className=\"tooltip-info\">MAL score: {selectedAnime.score}</span>       \n            </div> \n          : null}\n        </div>\n      </div>\n  )\n};\n\nexport default AnimeGraph;","/Users/dea/Code/Projects/animetimeline/src/Components/genres.js",["64"],"import * as chroma from \"chroma-js\";\nimport _ from \"lodash\";\n\n\nconst firstColour =  \"#21ABC0\"\nconst secondColour = \"#970C3F\"\nconst thirdColour =  \"#22223b\"\n\n// order genres by 'seriousness' \nconst orderedGenres = [\n  \"Kids\",\n  \"Comedy\",\n  \"School\",\n  'Shounen',\n  \"Shoujo\",\n  \"Fantasy\",\n  \"Super Power\",\n  \"Cars\",\n  \"Sports\",\n  \"Game\",\n  \"Adventure\",\n  \"Action\",\n  \"Demons\",\n  \"Samurai\",\n  \"Supernatural\",\n  'Magic',\n  \"Martial Arts\",\n  \"Mecha\",\n  \"Slice of Life\",\n  \"Parody\",\n  \"Romance\",\n  \"Music\",\n  \"Josei\",\n  \"Seinen\",  \n  \"Mystery\",\n  \"Horror\",\n  \"Thriller\",\n  \"Space\",\n  \"Police\",\n  \"Military\",\n  \"Drama\",\n  \"Historical\",\n  'Sci-Fi',\n  \"Psychological\",\n  \"Dementia\",\n]\n\n// these genres not included in the above list \nconst hentaiGenres = [\n  'Hentai',\n  \"Ecchi\",\n  \"Harem\",\n  \"Shounen Ai\",\n  \"Shoujo Ai\",\n  \"Yaoi\",\n  \"Yuri\",\n]\n\nconst colourScaleOrderedGenres = chroma.scale([firstColour, secondColour, thirdColour]\n  .map(color => chroma(color).brighten(0))\n  .map(color => chroma(color).saturate(0.1))\n  )\n  //.mode('lrgb') // hsl lrgb lab\n  .colors(orderedGenres.length)\n\n\n\nexport { orderedGenres, hentaiGenres, colourScaleOrderedGenres }",{"ruleId":"65","replacedBy":"66"},{"ruleId":"67","replacedBy":"68"},{"ruleId":"69","severity":1,"message":"70","line":62,"column":49,"nodeType":"71","messageId":"72","endLine":62,"endColumn":50,"fix":"73"},{"ruleId":"74","severity":1,"message":"75","line":2,"column":8,"nodeType":"76","messageId":"77","endLine":2,"endColumn":9},{"ruleId":"78","severity":1,"message":"79","line":10,"column":70,"nodeType":"80","endLine":10,"endColumn":121},{"ruleId":"74","severity":1,"message":"75","line":3,"column":8,"nodeType":"76","messageId":"77","endLine":3,"endColumn":9},{"ruleId":"74","severity":1,"message":"81","line":76,"column":13,"nodeType":"76","messageId":"77","endLine":76,"endColumn":29},{"ruleId":"74","severity":1,"message":"82","line":90,"column":13,"nodeType":"76","messageId":"77","endLine":90,"endColumn":27},{"ruleId":"74","severity":1,"message":"83","line":117,"column":13,"nodeType":"76","messageId":"77","endLine":117,"endColumn":28},{"ruleId":"84","severity":1,"message":"85","line":161,"column":6,"nodeType":"86","endLine":161,"endColumn":21,"suggestions":"87"},{"ruleId":"78","severity":1,"message":"79","line":20,"column":9,"nodeType":"80","endLine":20,"endColumn":60},{"ruleId":"78","severity":1,"message":"79","line":25,"column":9,"nodeType":"80","endLine":25,"endColumn":75},{"ruleId":"74","severity":1,"message":"88","line":6,"column":24,"nodeType":"76","messageId":"77","endLine":6,"endColumn":35},{"ruleId":"74","severity":1,"message":"89","line":56,"column":9,"nodeType":"76","messageId":"77","endLine":56,"endColumn":24},{"ruleId":"74","severity":1,"message":"90","line":60,"column":9,"nodeType":"76","messageId":"77","endLine":60,"endColumn":24},{"ruleId":"74","severity":1,"message":"91","line":79,"column":13,"nodeType":"76","messageId":"77","endLine":79,"endColumn":31},{"ruleId":"74","severity":1,"message":"92","line":136,"column":13,"nodeType":"76","messageId":"77","endLine":136,"endColumn":26},{"ruleId":"74","severity":1,"message":"93","line":182,"column":13,"nodeType":"76","messageId":"77","endLine":182,"endColumn":20},{"ruleId":"74","severity":1,"message":"94","line":304,"column":13,"nodeType":"76","messageId":"77","endLine":304,"endColumn":41},{"ruleId":"95","severity":1,"message":"96","line":342,"column":34,"nodeType":"97","messageId":"98","endLine":342,"endColumn":36},{"ruleId":"74","severity":1,"message":"99","line":378,"column":13,"nodeType":"76","messageId":"77","endLine":378,"endColumn":24},{"ruleId":"95","severity":1,"message":"96","line":396,"column":34,"nodeType":"97","messageId":"98","endLine":396,"endColumn":36},{"ruleId":"95","severity":1,"message":"96","line":397,"column":32,"nodeType":"97","messageId":"98","endLine":397,"endColumn":34},{"ruleId":"84","severity":1,"message":"100","line":415,"column":6,"nodeType":"86","endLine":415,"endColumn":57,"suggestions":"101"},{"ruleId":"74","severity":1,"message":"75","line":2,"column":8,"nodeType":"76","messageId":"77","endLine":2,"endColumn":9},"no-native-reassign",["102"],"no-negated-in-lhs",["103"],"dot-location","Expected dot to be on same line as property.","MemberExpression","expectedDotBeforeProperty",{"range":"104","text":"105"},"no-unused-vars","'_' is defined but never used.","Identifier","unusedVar","react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" is a security risk: see https://html.spec.whatwg.org/multipage/links.html#link-type-noopener","JSXOpeningElement","'instructionsText' is assigned a value but never used.","'rectBackground' is assigned a value but never used.","'yearCirclesText' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'margin.bottom', 'margin.left', 'margin.right', 'margin.top', and 'setSelectedYear'. Either include them or remove the dependency array. If 'setSelectedYear' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["106"],"'faRadiation' is defined but never used.","'allGenresColour' is assigned a value but never used.","'underratedScore' is assigned a value but never used.","'lowQuantileMembers' is assigned a value but never used.","'yAxisSideText' is assigned a value but never used.","'flowers' is assigned a value but never used.","'legendSelectedGenreTextFront' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'resetButton' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'margin.bottom', 'margin.left', 'margin.right', 'margin.top', 'maxPopularity', 'minPopularity', and 'petalScale'. Either include them or remove the dependency array.",["107"],"no-global-assign","no-unsafe-negation",[2422,2434],"\n          .",{"desc":"108","fix":"109"},{"desc":"110","fix":"111"},"Update the dependencies array to be: [data, allData, margin.left, margin.right, margin.top, margin.bottom, setSelectedYear]",{"range":"112","text":"113"},"Update the dependencies array to be: [allData, selectedYear, width, height, desktopSize, margin.right, margin.bottom, margin.top, margin.left, minPopularity, maxPopularity, petalScale]",{"range":"114","text":"115"},[5447,5462],"[data, allData, margin.left, margin.right, margin.top, margin.bottom, setSelectedYear]",[16731,16782],"[allData, selectedYear, width, height, desktopSize, margin.right, margin.bottom, margin.top, margin.left, minPopularity, maxPopularity, petalScale]"]