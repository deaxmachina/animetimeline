[{"/Users/dea/Code/Projects/animetimeline/src/index.js":"1","/Users/dea/Code/Projects/animetimeline/src/App.js":"2","/Users/dea/Code/Projects/animetimeline/src/Components/WholeViz.js":"3","/Users/dea/Code/Projects/animetimeline/src/Components/HeroSection.js":"4","/Users/dea/Code/Projects/animetimeline/src/Components/AnimeTimeline.js":"5","/Users/dea/Code/Projects/animetimeline/src/Components/Footer.js":"6","/Users/dea/Code/Projects/animetimeline/src/Components/AnimeGraph.js":"7","/Users/dea/Code/Projects/animetimeline/src/Components/genres.js":"8"},{"size":150,"mtime":1614562178501,"results":"9","hashOfConfig":"10"},{"size":169,"mtime":1614562178500,"results":"11","hashOfConfig":"10"},{"size":3709,"mtime":1614575008790,"results":"12","hashOfConfig":"10"},{"size":1502,"mtime":1614562178501,"results":"13","hashOfConfig":"10"},{"size":5801,"mtime":1614574733524,"results":"14","hashOfConfig":"10"},{"size":1520,"mtime":1614562178501,"results":"15","hashOfConfig":"10"},{"size":20034,"mtime":1614574954613,"results":"16","hashOfConfig":"10"},{"size":1148,"mtime":1614562178501,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"d15zvt",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"25","messages":"26","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"20"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"30","messages":"31","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32","usedDeprecatedRules":"20"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"20"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"20"},"/Users/dea/Code/Projects/animetimeline/src/index.js",[],["39","40"],"/Users/dea/Code/Projects/animetimeline/src/App.js",[],"/Users/dea/Code/Projects/animetimeline/src/Components/WholeViz.js",["41"],"/Users/dea/Code/Projects/animetimeline/src/Components/HeroSection.js",["42","43"],"import React from \"react\";\nimport _ from \"lodash\";\n\n\nconst HeroSection = () => {\n  return (\n    <div id=\"whole-graph-petalscircles-hero\">\n      <h1 className=\"whole-graph-petalscircles-title\">A Timeline of Anime</h1>\n      <div className=\"whole-graph-petalscircles-subtitle\">\n        Explore the evolution of anime over the decades with data from one of the most popular anime fan websites <a href=\"https://myanimelist.net/\" target=\"_blank\">MyAnimeList</a>\n      </div>\n\n      <div className=\"whole-graph-petalscircles-instructions\">\n        <p className=\"whole-graph-petalscircles-instructions-title\">How to read & interact with this visualisation</p>\n        <ul className=\"whole-graph-petalscircles-instructions-list\">\n          <li><span>Each circle in the graph below the timeline = one anime.</span></li>\n          <li><span>Sorted vertically by score (rating). Higher = greater score.</span></li>\n          <li><span>The bigger the anime circle, the more members have seen the anime.</span></li>  \n          <li><span>Number of constituent circles in each anime circle = number of genres. Genres are coloured as per the legend below.</span></li>    \n          <li><span>General tip: Play around, explore! Most elements can be clicked/and or hovered to reveal more information or filter.</span></li>\n        </ul>\n      </div>  \n      <p className=\"whole-graph-petalscircles-disclaimer\">\n        * Best viewed on a laptop/desktop screen.\n      </p>\n    </div>\n\n  )\n}\n\nexport default HeroSection;\n","/Users/dea/Code/Projects/animetimeline/src/Components/AnimeTimeline.js",["44","45","46","47","48"],"/Users/dea/Code/Projects/animetimeline/src/Components/Footer.js",["49","50"],"import React from \"react\";\n\nconst Footer = () => {\n  return (\n    <div className=\"whole-graph-petalscircles-footer\">  \n      <p className=\"whole-graph-petalscircles-methodology\">Methodology</p>\n      <ul className=\"whole-graph-petalscircles-methodology-list\">\n        <li>\n          For each anime, the anime is displayed once, even if it ran over multiple seasons. For long-running anime that means they end up being put in the winter season as it is the first of the year.\n        </li>\n        <li>\n          The colouring of the genres is based on a completely subjective ordering of \"seriousness\", aiming to give a visual representation of what kind of anime are most popular. \n        </li>\n        <li>\n          \"Popular but low score anime\" are defined as anime with number of members who have seen it in the 75th percentile, but with mean score below 6.5/10.\n        </li>\n      </ul>\n      <p className=\"whole-graph-petalscircles-p\">\n        Data from \n        <a href=\"https://myanimelist.net/\" target=\"_blank\"> MyAnimeList</a>. \n        I do not own any of the data.\n      </p>   \n      <p className=\"whole-graph-petalscircles-p\">\n        Project as part of 100DaysOfCode with D3.js challenge. Project inspiration: Shirley Wu Front End Masters \n        <a href=\"https://frontendmasters.com/courses/d3/\" target=\"_blank\"> course</a>.\n      </p>\n      <p className=\"whole-graph-petalscircles-p\">made by  \n        <span> Dea Bankova </span>\n      </p>\n      <p>2021</p>\n    </div>\n  )\n};\n\nexport default Footer;","/Users/dea/Code/Projects/animetimeline/src/Components/AnimeGraph.js",["51","52","53","54","55","56","57","58","59","60","61","62"],"import React, { useState, useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport _ from \"lodash\";\nimport { orderedGenres, colourScaleOrderedGenres, hentaiGenres } from \"./genres.js\"\n\n\n// options for the petal paths //\nconst petalPaths = [\n    'M0 0 C50 50 50 100 0 100 C-50 100 -50 50 0 0',\n    'M0 0 C1 1 1 2 0 2 C-1 2 -1 1 0 0',\n    'M-35 0 C-25 25 25 25 35 0 C50 25 25 75 0 100 C-25 75 -50 25 -35 0',\n    'M0,0 C50,40 50,70 20,100 L0,85 L-20,100 C-50,70 -50,40 0,0',\n    'M0 0 C50 25 50 75 0 100 C-50 75 -50 25 0 0',\n    \"M 0,0 a 25,25 0 1,1 50,0a 25,25 0 1,1 -50,0\",\n    \"M 0 -1 c 99 -45 74 -95 149 -97 c 87 0 85 98 227 97 c -142 1 -144 87 -228 88 c -77 1 -48 -52 -148 -88\",\n    \"M 0 0 c 0 29 49 19 50 -16 c -17 5 -43 -55 -50 16\",\n    \"M 0 0 C 59 26 48 79 10 63 L 0 68 L -9 63 C -46 78 -59 27 0 0\"\n]\n\n\nconst AnimeGraph = ({ \n  allData, selectedYear, setAllData, width, height, minPopularity, maxPopularity\n}) => {\n\n  const [selectedAnime, setSelectedAnime] = useState(null)\n\n  /// refs ///\n  const svgRef = useRef();\n  const xAxisRef = useRef();\n  const yAxisRef = useRef();\n  const gRef = useRef();\n  const nodesRef = useRef();\n  const legendRef = useRef();\n  const legendRectsAxisRef = useRef();\n  const tooltipRef = useRef();\n  const resetButtonRef = useRef();\n  const underratedButtonRef = useRef();\n\n  /// constatns ///\n  // dimensions \n  const legendHeight = 60;\n  const margin = {top: 20, bottom: legendHeight + 20, right: 30, left: 120}\n  \n  // for the lower and upper limit of the popularity scale\n  //const minPopularity = 7\n  //const maxPopularity = 47\n  // scale of the petals \n  const petalScale = 0.008 * 2;\n  // colours \n  const shapeBackgroundColour = \"#010B14\";\n  const lightColour =  \"#fff1e6\";\n  const circleOutlineHoverColour = \"black\"\n  const HentaiColour = \"#E2C6B6\";\n  const allGenresColour = \"#003f66\" //\"#2a9d8f\";\n\n  // for the filtering of anime \n  const underratedPercentile = 0.6;\n  const underratedScore = 7.5; // represents high score \n\n  const overratedPercentile = 0.75;\n  const overratedScore = 6.5; // represents low score \n\n\n  /// D3 Code ///\n  useEffect(() => {\n    if (allData && selectedYear) {\n\n      //////////////////////////////////////\n      ////////////// DATA //////////////////\n      //////////////////////////////////////\n      // get only one year \n      let dataOneYear = _.filter(allData, {'air_year': parseInt(selectedYear)});\n      // only the unique anime for the year \n      const dataOneYearUniq = _.uniqBy(dataOneYear, 'mal_id')\n      // get list of sorted members for computing the low and high quantiles\n      const sortedMembers = _.uniq(_.sortBy(allData, d => d.members).map(d => d.members))\n      const lowQuantileMembers = d3.quantile(sortedMembers, underratedPercentile)\n      const highQuantileMembers = d3.quantile(sortedMembers, overratedPercentile)\n\n      //////////////////////////////////////\n      /////////////// GRAPH ////////////////\n      //////////////////////////////////////\n      /// Scales ///\n      // X Scale \n      // use a band scale to position all the anime in the year horizontally \n      // this is needed with the force as it requires an x-position that \n      // the circles should move towards \n      const xScale = d3.scaleBand()\n        .domain(['winter', 'summer', 'spring', 'fall']) // the seasons in a year \n        .range([30, width - margin.right])\n        .padding(0.1)\n      // Y Scale - corresponds to the score of anime \n      const yScale = d3.scaleLinear()\n        .domain([d3.min(allData, d => d.score) + 1.5, d3.max(allData, d => d.score) + 1])\n        .range([height - margin.bottom, margin.top])\n      // Popularity scale - number of members who have seen the anime \n      const popularityScale = d3.scaleSqrt()\n        .domain(d3.extent(allData, d => d.members))\n        .range([minPopularity, maxPopularity])\n\n      // add radius for convenience\n      dataOneYearUniq.forEach(d => d.r = popularityScale(d.members))\n      // get list of the genres of anime\n      dataOneYearUniq.forEach(d => d.genresList = _.map(d.genres, \"name\"))\n      \n\n      /// Axes ///\n      // X Axis \n      const xAxis = g => g  \n        .attr(\"transform\", `translate(${100}, ${margin.top/2})`)\n        .call(d3.axisBottom(xScale).tickFormat(i => i).tickSizeOuter(0))\n        .call(g => g.select(\".domain\").remove())\n        .call(g => g.selectAll(\"text\")\n          .style(\"text-anchor\", \"start\")\n          .attr(\"font-size\", \"1.9em\")\n          .attr(\"class\", \"season\")\n          .style(\"color\", lightColour)\n        )\n        .call(g => g.selectAll(\".tick\")\n          .style(\"color\", shapeBackgroundColour)\n        )\n\n      // Y Axis \n      const yAxis = g => g\n        .attr(\"transform\", `translate(${margin.left}, ${0})`)\n        .call(d3.axisLeft(yScale).ticks(3))\n        .call(g => g.select(\".domain\").remove())\n\n      /// Graph ///\n      const svg = d3.select(gRef.current)\n        .attr(\"transform\", `translate(${margin.left}, ${0})`)\n\n      // text on the side of the y axis \n      const yAxisSideText = svg.selectAll(\".y-axis-side-text\").data([\"average user score of anime\"]).join(\"text\")\n        .classed(\"y-axis-side-text\", true)\n          .attr(\"x\", -height/2 + margin.top)\n          .attr(\"y\", -margin.left / 2)\n          .attr(\"text-anchor\", \"start\")\n          .attr(\"dy\", \"0.35em\")\n          .attr(\"font-size\", \"14px\")\n          .attr(\"fill-opacity\", 1)\n          .attr(\"opacity\", 1)\n          .attr(\"fill\", 'white')\n          .attr(\"transform\", `rotate(${-90})`)\n          .text(d => d)\n\n\n      // Force Simulation - to make the shapes not collide with each other\n      // note that we first remove the anime without a score as we don't want to visualise these \n      const dataOneYearUniqWithScores = _.filter(dataOneYearUniq, function(anime){ return anime['score'] !== null})\n      const simulation = d3.forceSimulation(dataOneYearUniqWithScores, d => d.mal_id)\n        // x is computed with the band scale \n        .force('x', d3.forceX().strength(0.3).x(d => xScale(d['air_season']) + xScale.bandwidth()/2))\n        // y is computed with the score \n        .force('y', d3.forceY().strength(0.9).y(d => yScale(d['score'])))\n        .force('collide', d3.forceCollide().radius(d => d.r + 2.5).strength(1)) // the + 2.5 is to leave some space between the circles \n  \n      // shapes - one for each anime; apply force simulation to these; also apply any click events at this level \n      const shapes = svg\n        .selectAll(\".shape-container\")\n        .data(simulation.nodes(), d => d['mal_id'])\n        .join(\"g\")\n        .classed(\"shape-container\", true)\n          .attr(\"opacity\", 0)\n          .attr('transform', d => `translate(${ d.x },${ d.y })`) \n        \n      // background for the shapes, e.g. \n      // a circle that contains the flowers for each anime\n      const shapesBackground = shapes.selectAll(\"circle\")\n        .data(d => [d])\n        .join(\"circle\")\n        .attr(\"r\", d => d.r)\n        .attr(\"fill\", shapeBackgroundColour)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"stroke\", lightColour)\n        .attr(\"stroke-width\", d => d.r * 0.15)\n        .attr('stroke-opacity', 1)\n\n      // the flower of shape for each anime based on the number of genres \n      const flowers = shapes.selectAll(\"path\")\n        .data(d => d.genres)\n        .join(\"path\")\n          .attr(\"d\", petalPaths[5]) // 7 or 5 \n          // the last arg nodes gives us access to the whole data\n          .attr(\"transform\", function(d, i, nodes){\n            const allData = d3.selectAll(nodes).data() // all data for this selection\n            const parentData = this.parentNode.__data__ // parent data\n            return `rotate(${i * (360 / (allData.length || 1))})scale(${petalScale * parentData.r || 0.2})`\n          })         \n          .attr(\"fill\", function(d, i, nodes){\n            const parentData = this.parentNode.__data__ // parent data\n            const genres = parentData.genres\n            // look up the indices of the genres in the ordered array of orderedGenres \n            // and use these to sort the anime in the order in which they appear in the orderedGenres \n            // so that we can have the petals form nice gradients when they have adjacent genres \n            const genresSorted = genres.sort((a, b) => {\n              return _.indexOf(orderedGenres, a.name) - _.indexOf(orderedGenres, b.name) \n            })\n            const genre =  genresSorted[i].name // get genre from parent data \n            // fill from the cat-based colour scheme \n            const fill = _.includes(orderedGenres, genre) \n              ? colourScaleOrderedGenres[_.indexOf(orderedGenres, genre)] \n              : HentaiColour\n            return fill\n          })\n          .attr(\"fill-opacity\", 0.83)\n          // same as fill\n          .attr(\"stroke\", function(d, i, nodes){\n            const parentData = this.parentNode.__data__ // parent data\n            const genres = parentData.genres\n            const genresSorted = genres.sort((a, b) => {\n              return _.indexOf(orderedGenres, a.name) - _.indexOf(orderedGenres, b.name) \n            })\n            const genre =  genresSorted[i].name // get genre from parent data \n            const fill = _.includes(orderedGenres, genre) \n              ? colourScaleOrderedGenres[_.indexOf(orderedGenres, genre)] \n              : HentaiColour\n            return fill\n          })\n          .attr(\"stroke-width\", 7)\n          .attr(\"stroke-opacity\", 0.3)\n\n      // ticks control the force simulation; translate the flowers to the right place\n      function tick() {\n        shapes\n        .attr('transform', d => `translate(${ d.x },${ d.y })`) \n      }\n      simulation.on(\"tick\", tick)\n\n      // shapes fade in; otherwise they enter from weird places\n      setTimeout(() => {\n        simulation.restart();\n        shapes\n          .transition()\n          .attr(\"opacity\", 1)\n      }, 100);\n      // show the initial arrangement\n      //tick();\n\n      // call the axes \n      d3.select(yAxisRef.current).call(yAxis)\n      d3.select(xAxisRef.current).call(xAxis)\n\n\n      //////////////////////////////////////////\n      //////////////// LEGEND //////////////////\n      //////////////////////////////////////////\n      const legend = d3.select(legendRef.current)\n        .attr(\"transform\", `translate(${0}, ${height + margin.top})`)\n\n      const xScaleLegend = d3.scaleBand()\n        .domain([...orderedGenres, ...hentaiGenres]) \n        .range([margin.left, width - margin.right + 45])\n        .padding(0.1)\n      \n      const legendRects = legend\n        .selectAll(\".legend-rect\")\n        .data([...orderedGenres, ...hentaiGenres])\n        .join(\"rect\")\n        .classed(\"legend-rect\", true)\n        .attr('height', 17)\n        .attr(\"width\", 24)\n        .attr(\"x\", (d, i) => xScaleLegend(d) + xScaleLegend.bandwidth()/2)\n        // fill based on genres, with the hentai genres separately and add a square with a different colour of \"all\" genres\n        .attr('fill', (d, i) => _.includes(orderedGenres, d) \n          ? colourScaleOrderedGenres[i] \n          : HentaiColour \n          )\n        .attr(\"opacity\", 0.8)\n\n      const legendRectsAxis = g => g  \n        .attr(\"transform\", `translate(${0}, ${height + margin.top + 20})`)\n        .attr(\"class\", \"legend-rects-xaxis\")\n        .call(d3.axisBottom(xScaleLegend).tickFormat(i => i).tickSizeOuter(0))\n        .call(g => g.select(\".domain\").remove())\n        .call(g => g.selectAll(\"text\")\n          .style(\"fill\", lightColour)\n          .attr(\"font-size\", \"1em\")\n          .style(\"text-anchor\", \"end\")\n          .attr(\"dy\", \".35em\")\n          .attr(\"dx\", \".35em\")\n          .attr(\"transform\", \"rotate(-30)\")\n        )\n        .call(g => g.selectAll(\".tick\")\n          .style(\"color\", shapeBackgroundColour)\n        )\n      d3.select(legendRectsAxisRef.current).call(legendRectsAxis)\n\n      // the genre text which is updated when a genre rect is clicked\n      const legendSelectedGenreText = legend\n        .selectAll(\".legend-selected-genre-text\")\n        .data([0])\n        .join(\"text\")\n        .classed(\"legend-selected-genre-text\", true)\n          .attr(\"transform\", `translate(${margin.left + 15}, ${-15})`)\n          .text(\"all genres\")\n          .attr(\"fill\", lightColour)\n          .style(\"text-anchor\", \"start\")\n          .attr(\"font-size\", \"2em\")\n\n      // bit of the text that stays constant and just says \"selected genre\"\n      const legendSelectedGenreTextFront = legend\n        .selectAll(\".legend-selected-genre-text-front\")\n        .data([0])\n        .join(\"text\")\n        .classed(\"legend-selected-genre-text-front\", true)\n          .attr(\"transform\", `translate(${margin.left + 15}, ${-50})`)\n          .text(\"currently selected genre\")\n          .attr(\"fill\", lightColour)\n          .style(\"text-anchor\", \"start\")\n          .attr(\"font-size\", \"0.95em\")\n\n      // text with instructions to select genre \n      const legendSelectedGenreTextInstructions = legend\n        .selectAll(\".legend-selected-genre-text-instructions\")\n        .data([0])\n        .join(\"text\")\n        .classed(\"legend-selected-genre-text-instructions\", true)\n          .attr(\"transform\", `translate(${width - margin.right + 50}, ${-15})`)\n          .text(\"click on a square to filter by genre\")\n          .attr(\"fill\", lightColour)\n          .style(\"text-anchor\", \"end\")\n          .attr(\"font-size\", \"0.85em\")\n          .attr(\"dy\", \"0.35em\")\n\n      /// Legend interactions ///\n      legendRects.on(\"click\", function(event, datum) {\n        const genre = datum \n        // the anime which contain that genre stay with opacity 1 and the other ones have reduced opacity. if there selected genre is \"all\", display everything \n        shapes.attr(\"opacity\", d => d.genresList.includes(genre) ? 1 : 0.1 \n        )\n        // change text to the genre in the text bit above the legend\n        legendSelectedGenreText.text(genre)\n      })\n      legendRects.on(\"mouseenter\", function(event, datum) {\n        // stroke the selected genre rect \n        legendRects\n          .attr(\"stroke\", d => d == datum ? lightColour : null)\n          .attr(\"stroke-width\", 2)\n      })\n      legendRects.on(\"mouseleave\", function(event, datum) {\n        legendRects\n          .attr(\"stroke\", null)\n      })\n\n      ////////////////////////////////////////\n      /////////// FILTER BUTTONS /////////////\n      ///////////////////////////////////////\n\n      // button for popular but low score\n\n      const underratedButton = d3.select(underratedButtonRef.current)\n        .on(\"click\", function(e, datum) {\n          shapes.attr(\"opacity\", 1)\n          legendSelectedGenreText.text(\"all genres\")\n        })\n        .on(\"click\", function() {\n          const overratedAnime = _.filter(allData, function(anime){ \n            return (anime.members >= highQuantileMembers && anime.score <= overratedScore)\n          })\n          shapes.attr(\"opacity\", d => overratedAnime.includes(d) ? 1 : 0.1)\n        })\n        .on(\"mouseenter\", function() {\n          underratedButton\n            .attr(\"stroke-width\", 3)\n        })\n        .on(\"mouseleave\", function() {\n          underratedButton\n            .attr(\"stroke-width\", 1)\n        })\n\n      /*\n      const underratedButtonG = legend\n          .selectAll(\".all-genres-button-g\")\n          .data([0])\n          .join(\"g\")\n          .classed(\".all-genres-button-g\", true)\n          .attr(\"transform\", `translate(${width - margin.right}, ${-65})`)\n          .on(\"click\", function(e, datum) {\n            shapes.attr(\"opacity\", 1)\n            legendSelectedGenreText.text(\"all genres\")\n          })\n          .on(\"click\", function() {\n            const overratedAnime = _.filter(allData, function(anime){ \n              return (anime.members >= highQuantileMembers && anime.score <= overratedScore)\n            })\n            shapes.attr(\"opacity\", d => overratedAnime.includes(d) ? 1 : 0.1)\n          })\n          .on(\"mouseenter\", function() {\n            underratedButtonRect\n              .attr(\"stroke-width\", 3)\n          })\n          .on(\"mouseleave\", function() {\n            underratedButtonRect\n              .attr(\"stroke-width\", 1)\n          })\n        \n      // rect for the button\n      const underratedButtonRect = underratedButtonG\n          .selectAll(\".legend-select-all-genres\")\n          .data([0])\n          .join(\"rect\")\n          .classed(\"legend-select-all-genres\", true)\n            .attr(\"transform\", `translate(${-109}, ${0})`)\n            .attr(\"fill\", shapeBackgroundColour)\n            .attr(\"width\", 160)\n            .attr(\"height\", 28)\n            .attr(\"stroke\", lightColour)\n            .attr(\"stroke-width\", 1)\n\n      // text on the button\n      const underratedButtonText = underratedButtonG\n          .selectAll(\".legend-select-all-genres-text\")\n          .data([\"popular but low score\"])\n          .join(\"text\")\n          .classed(\"legend-select-all-genres-text\", true)\n            .attr(\"transform\", `translate(${-90}, ${13})`)\n            .attr(\"fill\", lightColour)\n            .text(d => d)\n            .style(\"text-anchor\", \"start\")\n            .attr(\"font-size\", \"14px\")\n            .style(\"font-variant\", \"small-caps\")\n            .attr(\"font-family\", \"sans-serif\")\n            .attr(\"dy\", \"0.33em\")\n            .attr(\"dx\", \"-0.35em\")\n            .attr('cursor', 'default')\n            .attr('pointer-events', 'none')\n      */\n\n      // button for reset \n      const resetButton = d3.select(resetButtonRef.current)\n        .on(\"click\", function(){\n          shapes.attr(\"opacity\", 1)\n        })\n\n\n      //////////////////////////////////////\n      ////////////// TOOLTIP ///////////////\n      //////////////////////////////////////\n      // Include all the events here when an anime circle (shapes) is hovered or clicked \n      // i.e. the tooltip, stroke and the anime info that gets fetched \n      const tooltip = d3.select(tooltipRef.current)\n      // events to move the tooltip \n      shapes.on(\"click\", (event, element) => {\n        console.log(element)\n      })\n      shapes.on(\"mouseenter\", function(e, datum) {\n        shapesBackground\n          .attr(\"stroke\", d => d == datum ? circleOutlineHoverColour : lightColour)\n          .attr(\"fill\", d => d == datum ? lightColour : circleOutlineHoverColour)\n        tooltip \n          .style('transform', d => `translate(\n              ${datum.x}px,\n              ${datum.y + 80}px`\n            ) \n          .style(\"opacity\", 1)\n        // set the selected anime to the one corresponing to the hovered element \n        setSelectedAnime(datum)\n      })\n      shapes.on(\"mouseleave\", function(e, datum) {\n        shapesBackground\n          .attr(\"stroke\", lightColour)\n          .attr(\"fill\", shapeBackgroundColour)\n        tooltip.style(\"opacity\", 0)\n      })\n\n    } else {\n      console.log(\"Missing data\")\n    }\n  }, [allData, selectedYear, width, height]);\n\n\n  return (\n      <div>\n        <h1 className=\"whole-graph-petalscircles-selected-year\">{selectedYear}</h1>\n        <div id=\"anime-graph-wrapper\">\n          <svg \n            ref={svgRef} \n            width={width + margin.left + margin.right} \n            height={height + margin.top + margin.bottom}\n          >\n            <g ref={gRef}>\n              <g ref={nodesRef}></g>\n            </g>\n            <g ref={xAxisRef}></g>\n            <g ref={yAxisRef}></g>\n            <g ref={legendRef}></g>\n            <g ref={legendRectsAxisRef}></g>\n          </svg>\n        </div>\n\n        <button ref={resetButtonRef} className=\"reset-button\">reset</button>\n        <button ref={underratedButtonRef} className=\"underrated-button\">popular but low score</button>\n\n        <div id=\"tooltip\" className=\"tooltip\" ref={tooltipRef}>\n          {selectedAnime \n          ? <div>\n              <span className=\"tooltip-title\">{selectedAnime.title}</span>\n              <span className=\"tooltip-info\">MAL members: {d3.format(\",.2r\")(selectedAnime.members)}</span>\n              <span className=\"tooltip-info\">MAL score: {selectedAnime.score}</span>       \n            </div> \n          : null}\n        </div>\n      </div>\n  )\n};\n\nexport default AnimeGraph;","/Users/dea/Code/Projects/animetimeline/src/Components/genres.js",["63"],"import * as chroma from \"chroma-js\";\nimport _ from \"lodash\";\n\n\nconst firstColour =  \"#21ABC0\"\nconst secondColour = \"#970C3F\"\nconst thirdColour =  \"#22223b\"\n\n// order genres by 'seriousness' \nconst orderedGenres = [\n  \"Kids\",\n  \"Comedy\",\n  \"School\",\n  'Shounen',\n  \"Shoujo\",\n  \"Fantasy\",\n  \"Super Power\",\n  \"Cars\",\n  \"Sports\",\n  \"Game\",\n  \"Adventure\",\n  \"Action\",\n  \"Demons\",\n  \"Samurai\",\n  \"Supernatural\",\n  'Magic',\n  \"Martial Arts\",\n  \"Mecha\",\n  \"Slice of Life\",\n  \"Parody\",\n  \"Romance\",\n  \"Music\",\n  \"Josei\",\n  \"Seinen\",  \n  \"Mystery\",\n  \"Horror\",\n  \"Thriller\",\n  \"Space\",\n  \"Police\",\n  \"Military\",\n  \"Drama\",\n  \"Historical\",\n  'Sci-Fi',\n  \"Psychological\",\n  \"Dementia\",\n]\n\n// these genres not included in the above list \nconst hentaiGenres = [\n  'Hentai',\n  \"Ecchi\",\n  \"Harem\",\n  \"Shounen Ai\",\n  \"Shoujo Ai\",\n  \"Yaoi\",\n  \"Yuri\",\n]\n\nconst colourScaleOrderedGenres = chroma.scale([firstColour, secondColour, thirdColour]\n  .map(color => chroma(color).brighten(0))\n  .map(color => chroma(color).saturate(0.1))\n  )\n  //.mode('lrgb') // hsl lrgb lab\n  .colors(orderedGenres.length)\n\n\n\nexport { orderedGenres, hentaiGenres, colourScaleOrderedGenres }",{"ruleId":"64","replacedBy":"65"},{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","severity":1,"message":"69","line":60,"column":49,"nodeType":"70","messageId":"71","endLine":60,"endColumn":50,"fix":"72"},{"ruleId":"73","severity":1,"message":"74","line":2,"column":8,"nodeType":"75","messageId":"76","endLine":2,"endColumn":9},{"ruleId":"77","severity":1,"message":"78","line":10,"column":115,"nodeType":"79","endLine":10,"endColumn":166},{"ruleId":"73","severity":1,"message":"74","line":3,"column":8,"nodeType":"75","messageId":"76","endLine":3,"endColumn":9},{"ruleId":"73","severity":1,"message":"80","line":76,"column":13,"nodeType":"75","messageId":"76","endLine":76,"endColumn":29},{"ruleId":"73","severity":1,"message":"81","line":90,"column":13,"nodeType":"75","messageId":"76","endLine":90,"endColumn":27},{"ruleId":"73","severity":1,"message":"82","line":117,"column":13,"nodeType":"75","messageId":"76","endLine":117,"endColumn":28},{"ruleId":"83","severity":1,"message":"84","line":161,"column":6,"nodeType":"85","endLine":161,"endColumn":21,"suggestions":"86"},{"ruleId":"77","severity":1,"message":"78","line":20,"column":9,"nodeType":"79","endLine":20,"endColumn":60},{"ruleId":"77","severity":1,"message":"78","line":25,"column":9,"nodeType":"79","endLine":25,"endColumn":75},{"ruleId":"73","severity":1,"message":"87","line":54,"column":9,"nodeType":"75","messageId":"76","endLine":54,"endColumn":24},{"ruleId":"73","severity":1,"message":"88","line":58,"column":9,"nodeType":"75","messageId":"76","endLine":58,"endColumn":24},{"ruleId":"73","severity":1,"message":"89","line":77,"column":13,"nodeType":"75","messageId":"76","endLine":77,"endColumn":31},{"ruleId":"73","severity":1,"message":"90","line":134,"column":13,"nodeType":"75","messageId":"76","endLine":134,"endColumn":26},{"ruleId":"73","severity":1,"message":"91","line":180,"column":13,"nodeType":"75","messageId":"76","endLine":180,"endColumn":20},{"ruleId":"73","severity":1,"message":"92","line":302,"column":13,"nodeType":"75","messageId":"76","endLine":302,"endColumn":41},{"ruleId":"73","severity":1,"message":"93","line":314,"column":13,"nodeType":"75","messageId":"76","endLine":314,"endColumn":48},{"ruleId":"94","severity":1,"message":"95","line":338,"column":34,"nodeType":"96","messageId":"97","endLine":338,"endColumn":36},{"ruleId":"73","severity":1,"message":"98","line":431,"column":13,"nodeType":"75","messageId":"76","endLine":431,"endColumn":24},{"ruleId":"94","severity":1,"message":"95","line":449,"column":34,"nodeType":"96","messageId":"97","endLine":449,"endColumn":36},{"ruleId":"94","severity":1,"message":"95","line":450,"column":32,"nodeType":"96","messageId":"97","endLine":450,"endColumn":34},{"ruleId":"83","severity":1,"message":"99","line":470,"column":6,"nodeType":"85","endLine":470,"endColumn":44,"suggestions":"100"},{"ruleId":"73","severity":1,"message":"74","line":2,"column":8,"nodeType":"75","messageId":"76","endLine":2,"endColumn":9},"no-native-reassign",["101"],"no-negated-in-lhs",["102"],"dot-location","Expected dot to be on same line as property.","MemberExpression","expectedDotBeforeProperty",{"range":"103","text":"104"},"no-unused-vars","'_' is defined but never used.","Identifier","unusedVar","react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" is a security risk: see https://html.spec.whatwg.org/multipage/links.html#link-type-noopener","JSXOpeningElement","'instructionsText' is assigned a value but never used.","'rectBackground' is assigned a value but never used.","'yearCirclesText' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'margin.bottom', 'margin.left', 'margin.right', 'margin.top', and 'setSelectedYear'. Either include them or remove the dependency array. If 'setSelectedYear' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["105"],"'allGenresColour' is assigned a value but never used.","'underratedScore' is assigned a value but never used.","'lowQuantileMembers' is assigned a value but never used.","'yAxisSideText' is assigned a value but never used.","'flowers' is assigned a value but never used.","'legendSelectedGenreTextFront' is assigned a value but never used.","'legendSelectedGenreTextInstructions' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'resetButton' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'margin.bottom', 'margin.left', 'margin.right', 'margin.top', 'maxPopularity', 'minPopularity', and 'petalScale'. Either include them or remove the dependency array.",["106"],"no-global-assign","no-unsafe-negation",[2328,2340],"\n          .",{"desc":"107","fix":"108"},{"desc":"109","fix":"110"},"Update the dependencies array to be: [data, allData, margin.left, margin.right, margin.top, margin.bottom, setSelectedYear]",{"range":"111","text":"112"},"Update the dependencies array to be: [allData, selectedYear, width, height, margin.right, margin.bottom, margin.top, margin.left, minPopularity, maxPopularity, petalScale]",{"range":"113","text":"114"},[5445,5460],"[data, allData, margin.left, margin.right, margin.top, margin.bottom, setSelectedYear]",[18749,18787],"[allData, selectedYear, width, height, margin.right, margin.bottom, margin.top, margin.left, minPopularity, maxPopularity, petalScale]"]